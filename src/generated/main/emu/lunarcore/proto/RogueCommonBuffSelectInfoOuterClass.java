// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedInt;
import us.hebi.quickbuf.RepeatedMessage;

public final class RogueCommonBuffSelectInfoOuterClass {
  /**
   * Protobuf type {@code RogueCommonBuffSelectInfo}
   */
  public static final class RogueCommonBuffSelectInfo extends ProtoMessage<RogueCommonBuffSelectInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 source_total_count = 1;</code>
     */
    private int sourceTotalCount;

    /**
     * <code>optional uint32 source_hint_id = 4;</code>
     */
    private int sourceHintId;

    /**
     * <code>optional uint32 roll_buff_free_count = 8;</code>
     */
    private int rollBuffFreeCount;

    /**
     * <code>optional uint32 roll_buff_max_count = 9;</code>
     */
    private int rollBuffMaxCount;

    /**
     * <code>optional uint32 source_cur_count = 10;</code>
     */
    private int sourceCurCount;

    /**
     * <code>optional uint32 roll_buff_count = 11;</code>
     */
    private int rollBuffCount;

    /**
     * <code>optional .RogueCommonBuffSelectSource source_type = 14;</code>
     */
    private int sourceType;

    /**
     * <code>optional bool can_roll = 2;</code>
     */
    private boolean canRoll;

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     */
    private final ItemCostListOuterClass.ItemCostList rollBuffCostData = ItemCostListOuterClass.ItemCostList.newInstance();

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     */
    private final RepeatedInt firstBuffTypeList = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     */
    private final RepeatedInt handbookUnlockBuffIdList = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     */
    private final RepeatedMessage<JOOJNLEGJMM> selectBuffList = RepeatedMessage.newEmptyInstance(JOOJNLEGJMM.getFactory());

    private RogueCommonBuffSelectInfo() {
    }

    /**
     * @return a new empty instance of {@code RogueCommonBuffSelectInfo}
     */
    public static RogueCommonBuffSelectInfo newInstance() {
      return new RogueCommonBuffSelectInfo();
    }

    /**
     * <code>optional uint32 source_total_count = 1;</code>
     * @return whether the sourceTotalCount field is set
     */
    public boolean hasSourceTotalCount() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 source_total_count = 1;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearSourceTotalCount() {
      bitField0_ &= ~0x00000001;
      sourceTotalCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 source_total_count = 1;</code>
     * @return the sourceTotalCount
     */
    public int getSourceTotalCount() {
      return sourceTotalCount;
    }

    /**
     * <code>optional uint32 source_total_count = 1;</code>
     * @param value the sourceTotalCount to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setSourceTotalCount(final int value) {
      bitField0_ |= 0x00000001;
      sourceTotalCount = value;
      return this;
    }

    /**
     * <code>optional uint32 source_hint_id = 4;</code>
     * @return whether the sourceHintId field is set
     */
    public boolean hasSourceHintId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 source_hint_id = 4;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearSourceHintId() {
      bitField0_ &= ~0x00000002;
      sourceHintId = 0;
      return this;
    }

    /**
     * <code>optional uint32 source_hint_id = 4;</code>
     * @return the sourceHintId
     */
    public int getSourceHintId() {
      return sourceHintId;
    }

    /**
     * <code>optional uint32 source_hint_id = 4;</code>
     * @param value the sourceHintId to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setSourceHintId(final int value) {
      bitField0_ |= 0x00000002;
      sourceHintId = value;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_free_count = 8;</code>
     * @return whether the rollBuffFreeCount field is set
     */
    public boolean hasRollBuffFreeCount() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 roll_buff_free_count = 8;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearRollBuffFreeCount() {
      bitField0_ &= ~0x00000004;
      rollBuffFreeCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_free_count = 8;</code>
     * @return the rollBuffFreeCount
     */
    public int getRollBuffFreeCount() {
      return rollBuffFreeCount;
    }

    /**
     * <code>optional uint32 roll_buff_free_count = 8;</code>
     * @param value the rollBuffFreeCount to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setRollBuffFreeCount(final int value) {
      bitField0_ |= 0x00000004;
      rollBuffFreeCount = value;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_max_count = 9;</code>
     * @return whether the rollBuffMaxCount field is set
     */
    public boolean hasRollBuffMaxCount() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 roll_buff_max_count = 9;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearRollBuffMaxCount() {
      bitField0_ &= ~0x00000008;
      rollBuffMaxCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_max_count = 9;</code>
     * @return the rollBuffMaxCount
     */
    public int getRollBuffMaxCount() {
      return rollBuffMaxCount;
    }

    /**
     * <code>optional uint32 roll_buff_max_count = 9;</code>
     * @param value the rollBuffMaxCount to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setRollBuffMaxCount(final int value) {
      bitField0_ |= 0x00000008;
      rollBuffMaxCount = value;
      return this;
    }

    /**
     * <code>optional uint32 source_cur_count = 10;</code>
     * @return whether the sourceCurCount field is set
     */
    public boolean hasSourceCurCount() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 source_cur_count = 10;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearSourceCurCount() {
      bitField0_ &= ~0x00000010;
      sourceCurCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 source_cur_count = 10;</code>
     * @return the sourceCurCount
     */
    public int getSourceCurCount() {
      return sourceCurCount;
    }

    /**
     * <code>optional uint32 source_cur_count = 10;</code>
     * @param value the sourceCurCount to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setSourceCurCount(final int value) {
      bitField0_ |= 0x00000010;
      sourceCurCount = value;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_count = 11;</code>
     * @return whether the rollBuffCount field is set
     */
    public boolean hasRollBuffCount() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 roll_buff_count = 11;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearRollBuffCount() {
      bitField0_ &= ~0x00000020;
      rollBuffCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_buff_count = 11;</code>
     * @return the rollBuffCount
     */
    public int getRollBuffCount() {
      return rollBuffCount;
    }

    /**
     * <code>optional uint32 roll_buff_count = 11;</code>
     * @param value the rollBuffCount to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setRollBuffCount(final int value) {
      bitField0_ |= 0x00000020;
      rollBuffCount = value;
      return this;
    }

    /**
     * <code>optional .RogueCommonBuffSelectSource source_type = 14;</code>
     * @return whether the sourceType field is set
     */
    public boolean hasSourceType() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .RogueCommonBuffSelectSource source_type = 14;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearSourceType() {
      bitField0_ &= ~0x00000040;
      sourceType = 0;
      return this;
    }

    /**
     * <code>optional .RogueCommonBuffSelectSource source_type = 14;</code>
     * @return the sourceType
     */
    public RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource getSourceType() {
      return RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource.forNumber(sourceType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RogueCommonBuffSelectInfo#getSourceType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getSourceTypeValue() {
      return sourceType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource}. Setting an invalid value
     * can cause {@link RogueCommonBuffSelectInfo#getSourceType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setSourceTypeValue(final int value) {
      bitField0_ |= 0x00000040;
      sourceType = value;
      return this;
    }

    /**
     * <code>optional .RogueCommonBuffSelectSource source_type = 14;</code>
     * @param value the sourceType to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setSourceType(
        final RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource value) {
      bitField0_ |= 0x00000040;
      sourceType = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool can_roll = 2;</code>
     * @return whether the canRoll field is set
     */
    public boolean hasCanRoll() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional bool can_roll = 2;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearCanRoll() {
      bitField0_ &= ~0x00000080;
      canRoll = false;
      return this;
    }

    /**
     * <code>optional bool can_roll = 2;</code>
     * @return the canRoll
     */
    public boolean getCanRoll() {
      return canRoll;
    }

    /**
     * <code>optional bool can_roll = 2;</code>
     * @param value the canRoll to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setCanRoll(final boolean value) {
      bitField0_ |= 0x00000080;
      canRoll = value;
      return this;
    }

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     * @return whether the rollBuffCostData field is set
     */
    public boolean hasRollBuffCostData() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearRollBuffCostData() {
      bitField0_ &= ~0x00000100;
      rollBuffCostData.clear();
      return this;
    }

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRollBuffCostData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ItemCostListOuterClass.ItemCostList getRollBuffCostData() {
      return rollBuffCostData;
    }

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ItemCostListOuterClass.ItemCostList getMutableRollBuffCostData() {
      bitField0_ |= 0x00000100;
      return rollBuffCostData;
    }

    /**
     * <code>optional .ItemCostList roll_buff_cost_data = 12;</code>
     * @param value the rollBuffCostData to set
     * @return this
     */
    public RogueCommonBuffSelectInfo setRollBuffCostData(
        final ItemCostListOuterClass.ItemCostList value) {
      bitField0_ |= 0x00000100;
      rollBuffCostData.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     * @return whether the firstBuffTypeList field is set
     */
    public boolean hasFirstBuffTypeList() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearFirstBuffTypeList() {
      bitField0_ &= ~0x00000200;
      firstBuffTypeList.clear();
      return this;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableFirstBuffTypeList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getFirstBuffTypeList() {
      return firstBuffTypeList;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableFirstBuffTypeList() {
      bitField0_ |= 0x00000200;
      return firstBuffTypeList;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     * @param value the firstBuffTypeList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addFirstBuffTypeList(final int value) {
      bitField0_ |= 0x00000200;
      firstBuffTypeList.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 first_buff_type_list = 6;</code>
     * @param values the firstBuffTypeList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addAllFirstBuffTypeList(final int... values) {
      bitField0_ |= 0x00000200;
      firstBuffTypeList.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     * @return whether the handbookUnlockBuffIdList field is set
     */
    public boolean hasHandbookUnlockBuffIdList() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearHandbookUnlockBuffIdList() {
      bitField0_ &= ~0x00000400;
      handbookUnlockBuffIdList.clear();
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHandbookUnlockBuffIdList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getHandbookUnlockBuffIdList() {
      return handbookUnlockBuffIdList;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableHandbookUnlockBuffIdList() {
      bitField0_ |= 0x00000400;
      return handbookUnlockBuffIdList;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     * @param value the handbookUnlockBuffIdList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addHandbookUnlockBuffIdList(final int value) {
      bitField0_ |= 0x00000400;
      handbookUnlockBuffIdList.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_buff_id_list = 15;</code>
     * @param values the handbookUnlockBuffIdList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addAllHandbookUnlockBuffIdList(final int... values) {
      bitField0_ |= 0x00000400;
      handbookUnlockBuffIdList.addAll(values);
      return this;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     * @return whether the selectBuffList field is set
     */
    public boolean hasSelectBuffList() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     * @return this
     */
    public RogueCommonBuffSelectInfo clearSelectBuffList() {
      bitField0_ &= ~0x00000800;
      selectBuffList.clear();
      return this;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectBuffList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<JOOJNLEGJMM> getSelectBuffList() {
      return selectBuffList;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<JOOJNLEGJMM> getMutableSelectBuffList() {
      bitField0_ |= 0x00000800;
      return selectBuffList;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     * @param value the selectBuffList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addSelectBuffList(final JOOJNLEGJMM value) {
      bitField0_ |= 0x00000800;
      selectBuffList.add(value);
      return this;
    }

    /**
     * <code>repeated .JOOJNLEGJMM select_buff_list = 7;</code>
     * @param values the selectBuffList to add
     * @return this
     */
    public RogueCommonBuffSelectInfo addAllSelectBuffList(final JOOJNLEGJMM... values) {
      bitField0_ |= 0x00000800;
      selectBuffList.addAll(values);
      return this;
    }

    @Override
    public RogueCommonBuffSelectInfo copyFrom(final RogueCommonBuffSelectInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        sourceTotalCount = other.sourceTotalCount;
        sourceHintId = other.sourceHintId;
        rollBuffFreeCount = other.rollBuffFreeCount;
        rollBuffMaxCount = other.rollBuffMaxCount;
        sourceCurCount = other.sourceCurCount;
        rollBuffCount = other.rollBuffCount;
        sourceType = other.sourceType;
        canRoll = other.canRoll;
        rollBuffCostData.copyFrom(other.rollBuffCostData);
        firstBuffTypeList.copyFrom(other.firstBuffTypeList);
        handbookUnlockBuffIdList.copyFrom(other.handbookUnlockBuffIdList);
        selectBuffList.copyFrom(other.selectBuffList);
      }
      return this;
    }

    @Override
    public RogueCommonBuffSelectInfo mergeFrom(final RogueCommonBuffSelectInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasSourceTotalCount()) {
        setSourceTotalCount(other.sourceTotalCount);
      }
      if (other.hasSourceHintId()) {
        setSourceHintId(other.sourceHintId);
      }
      if (other.hasRollBuffFreeCount()) {
        setRollBuffFreeCount(other.rollBuffFreeCount);
      }
      if (other.hasRollBuffMaxCount()) {
        setRollBuffMaxCount(other.rollBuffMaxCount);
      }
      if (other.hasSourceCurCount()) {
        setSourceCurCount(other.sourceCurCount);
      }
      if (other.hasRollBuffCount()) {
        setRollBuffCount(other.rollBuffCount);
      }
      if (other.hasSourceType()) {
        setSourceTypeValue(other.sourceType);
      }
      if (other.hasCanRoll()) {
        setCanRoll(other.canRoll);
      }
      if (other.hasRollBuffCostData()) {
        getMutableRollBuffCostData().mergeFrom(other.rollBuffCostData);
      }
      if (other.hasFirstBuffTypeList()) {
        getMutableFirstBuffTypeList().addAll(other.firstBuffTypeList);
      }
      if (other.hasHandbookUnlockBuffIdList()) {
        getMutableHandbookUnlockBuffIdList().addAll(other.handbookUnlockBuffIdList);
      }
      if (other.hasSelectBuffList()) {
        getMutableSelectBuffList().addAll(other.selectBuffList);
      }
      return this;
    }

    @Override
    public RogueCommonBuffSelectInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      sourceTotalCount = 0;
      sourceHintId = 0;
      rollBuffFreeCount = 0;
      rollBuffMaxCount = 0;
      sourceCurCount = 0;
      rollBuffCount = 0;
      sourceType = 0;
      canRoll = false;
      rollBuffCostData.clear();
      firstBuffTypeList.clear();
      handbookUnlockBuffIdList.clear();
      selectBuffList.clear();
      return this;
    }

    @Override
    public RogueCommonBuffSelectInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rollBuffCostData.clearQuick();
      firstBuffTypeList.clear();
      handbookUnlockBuffIdList.clear();
      selectBuffList.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RogueCommonBuffSelectInfo)) {
        return false;
      }
      RogueCommonBuffSelectInfo other = (RogueCommonBuffSelectInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasSourceTotalCount() || sourceTotalCount == other.sourceTotalCount)
        && (!hasSourceHintId() || sourceHintId == other.sourceHintId)
        && (!hasRollBuffFreeCount() || rollBuffFreeCount == other.rollBuffFreeCount)
        && (!hasRollBuffMaxCount() || rollBuffMaxCount == other.rollBuffMaxCount)
        && (!hasSourceCurCount() || sourceCurCount == other.sourceCurCount)
        && (!hasRollBuffCount() || rollBuffCount == other.rollBuffCount)
        && (!hasSourceType() || sourceType == other.sourceType)
        && (!hasCanRoll() || canRoll == other.canRoll)
        && (!hasRollBuffCostData() || rollBuffCostData.equals(other.rollBuffCostData))
        && (!hasFirstBuffTypeList() || firstBuffTypeList.equals(other.firstBuffTypeList))
        && (!hasHandbookUnlockBuffIdList() || handbookUnlockBuffIdList.equals(other.handbookUnlockBuffIdList))
        && (!hasSelectBuffList() || selectBuffList.equals(other.selectBuffList));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(sourceTotalCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(sourceHintId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(rollBuffFreeCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(rollBuffMaxCount);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 80);
        output.writeUInt32NoTag(sourceCurCount);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(rollBuffCount);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 112);
        output.writeEnumNoTag(sourceType);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 16);
        output.writeBoolNoTag(canRoll);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 98);
        output.writeMessageNoTag(rollBuffCostData);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        for (int i = 0; i < firstBuffTypeList.length(); i++) {
          output.writeRawByte((byte) 48);
          output.writeUInt32NoTag(firstBuffTypeList.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000400) != 0) {
        for (int i = 0; i < handbookUnlockBuffIdList.length(); i++) {
          output.writeRawByte((byte) 120);
          output.writeUInt32NoTag(handbookUnlockBuffIdList.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000800) != 0) {
        for (int i = 0; i < selectBuffList.length(); i++) {
          output.writeRawByte((byte) 58);
          output.writeMessageNoTag(selectBuffList.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sourceTotalCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sourceHintId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollBuffFreeCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollBuffMaxCount);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(sourceCurCount);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollBuffCount);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(sourceType);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rollBuffCostData);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += (1 * firstBuffTypeList.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(firstBuffTypeList);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += (1 * handbookUnlockBuffIdList.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(handbookUnlockBuffIdList);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += (1 * selectBuffList.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(selectBuffList);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RogueCommonBuffSelectInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // sourceTotalCount
            sourceTotalCount = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // sourceHintId
            sourceHintId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // rollBuffFreeCount
            rollBuffFreeCount = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // rollBuffMaxCount
            rollBuffMaxCount = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // sourceCurCount
            sourceCurCount = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // rollBuffCount
            rollBuffCount = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // sourceType
            final int value = input.readInt32();
            if (RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource.forNumber(value) != null) {
              sourceType = value;
              bitField0_ |= 0x00000040;
            }
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // canRoll
            canRoll = input.readBool();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // rollBuffCostData
            input.readMessage(rollBuffCostData);
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 50) {
              break;
            }
          }
          case 50: {
            // firstBuffTypeList [packed=true]
            input.readPackedUInt32(firstBuffTypeList, tag);
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // handbookUnlockBuffIdList [packed=true]
            input.readPackedUInt32(handbookUnlockBuffIdList, tag);
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // selectBuffList
            tag = input.readRepeatedMessage(selectBuffList, tag);
            bitField0_ |= 0x00000800;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 48: {
            // firstBuffTypeList [packed=false]
            tag = input.readRepeatedUInt32(firstBuffTypeList, tag);
            bitField0_ |= 0x00000200;
            break;
          }
          case 120: {
            // handbookUnlockBuffIdList [packed=false]
            tag = input.readRepeatedUInt32(handbookUnlockBuffIdList, tag);
            bitField0_ |= 0x00000400;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.sourceTotalCount, sourceTotalCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.sourceHintId, sourceHintId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.rollBuffFreeCount, rollBuffFreeCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.rollBuffMaxCount, rollBuffMaxCount);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.sourceCurCount, sourceCurCount);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.rollBuffCount, rollBuffCount);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeEnum(FieldNames.sourceType, sourceType, RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource.converter());
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeBool(FieldNames.canRoll, canRoll);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeMessage(FieldNames.rollBuffCostData, rollBuffCostData);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRepeatedUInt32(FieldNames.firstBuffTypeList, firstBuffTypeList);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRepeatedUInt32(FieldNames.handbookUnlockBuffIdList, handbookUnlockBuffIdList);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRepeatedMessage(FieldNames.selectBuffList, selectBuffList);
      }
      output.endObject();
    }

    @Override
    public RogueCommonBuffSelectInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1098445146:
          case -1750826448: {
            if (input.isAtField(FieldNames.sourceTotalCount)) {
              if (!input.trySkipNullValue()) {
                sourceTotalCount = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1002632701:
          case 1852372399: {
            if (input.isAtField(FieldNames.sourceHintId)) {
              if (!input.trySkipNullValue()) {
                sourceHintId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -227537549:
          case -710203098: {
            if (input.isAtField(FieldNames.rollBuffFreeCount)) {
              if (!input.trySkipNullValue()) {
                rollBuffFreeCount = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -580244325:
          case -808042102: {
            if (input.isAtField(FieldNames.rollBuffMaxCount)) {
              if (!input.trySkipNullValue()) {
                rollBuffMaxCount = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -831207446:
          case 557368108: {
            if (input.isAtField(FieldNames.sourceCurCount)) {
              if (!input.trySkipNullValue()) {
                sourceCurCount = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -451729281:
          case 2022821669: {
            if (input.isAtField(FieldNames.rollBuffCount)) {
              if (!input.trySkipNullValue()) {
                rollBuffCount = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1111431691:
          case -84625186: {
            if (input.isAtField(FieldNames.sourceType)) {
              if (!input.trySkipNullValue()) {
                final RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource value = input.readEnum(RogueCommonBuffSelectSourceOuterClass.RogueCommonBuffSelectSource.converter());
                if (value != null) {
                  sourceType = value.getNumber();
                  bitField0_ |= 0x00000040;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 549719149:
          case -126477428: {
            if (input.isAtField(FieldNames.canRoll)) {
              if (!input.trySkipNullValue()) {
                canRoll = input.readBool();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1387522137:
          case -829205518: {
            if (input.isAtField(FieldNames.rollBuffCostData)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(rollBuffCostData);
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2103912645:
          case -1677036794: {
            if (input.isAtField(FieldNames.firstBuffTypeList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(firstBuffTypeList);
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 620352744:
          case 2008489866: {
            if (input.isAtField(FieldNames.handbookUnlockBuffIdList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(handbookUnlockBuffIdList);
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -570494803:
          case 1195538823: {
            if (input.isAtField(FieldNames.selectBuffList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(selectBuffList);
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RogueCommonBuffSelectInfo clone() {
      return new RogueCommonBuffSelectInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RogueCommonBuffSelectInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RogueCommonBuffSelectInfo(), data).checkInitialized();
    }

    public static RogueCommonBuffSelectInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueCommonBuffSelectInfo(), input).checkInitialized();
    }

    public static RogueCommonBuffSelectInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueCommonBuffSelectInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating RogueCommonBuffSelectInfo messages
     */
    public static MessageFactory<RogueCommonBuffSelectInfo> getFactory() {
      return RogueCommonBuffSelectInfoFactory.INSTANCE;
    }

    private enum RogueCommonBuffSelectInfoFactory implements MessageFactory<RogueCommonBuffSelectInfo> {
      INSTANCE;

      @Override
      public RogueCommonBuffSelectInfo create() {
        return RogueCommonBuffSelectInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName sourceTotalCount = FieldName.forField("sourceTotalCount", "source_total_count");

      static final FieldName sourceHintId = FieldName.forField("sourceHintId", "source_hint_id");

      static final FieldName rollBuffFreeCount = FieldName.forField("rollBuffFreeCount", "roll_buff_free_count");

      static final FieldName rollBuffMaxCount = FieldName.forField("rollBuffMaxCount", "roll_buff_max_count");

      static final FieldName sourceCurCount = FieldName.forField("sourceCurCount", "source_cur_count");

      static final FieldName rollBuffCount = FieldName.forField("rollBuffCount", "roll_buff_count");

      static final FieldName sourceType = FieldName.forField("sourceType", "source_type");

      static final FieldName canRoll = FieldName.forField("canRoll", "can_roll");

      static final FieldName rollBuffCostData = FieldName.forField("rollBuffCostData", "roll_buff_cost_data");

      static final FieldName firstBuffTypeList = FieldName.forField("firstBuffTypeList", "first_buff_type_list");

      static final FieldName handbookUnlockBuffIdList = FieldName.forField("handbookUnlockBuffIdList", "handbook_unlock_buff_id_list");

      static final FieldName selectBuffList = FieldName.forField("selectBuffList", "select_buff_list");
    }
  }

  /**
   * Protobuf type {@code JOOJNLEGJMM}
   */
  public static final class JOOJNLEGJMM extends ProtoMessage<JOOJNLEGJMM> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 buff_id = 5;</code>
     */
    private int buffId;

    /**
     * <code>optional uint32 JAIMPOFNKFJ = 9;</code>
     */
    private int jAIMPOFNKFJ;

    private JOOJNLEGJMM() {
    }

    /**
     * @return a new empty instance of {@code JOOJNLEGJMM}
     */
    public static JOOJNLEGJMM newInstance() {
      return new JOOJNLEGJMM();
    }

    /**
     * <code>optional uint32 buff_id = 5;</code>
     * @return whether the buffId field is set
     */
    public boolean hasBuffId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 buff_id = 5;</code>
     * @return this
     */
    public JOOJNLEGJMM clearBuffId() {
      bitField0_ &= ~0x00000001;
      buffId = 0;
      return this;
    }

    /**
     * <code>optional uint32 buff_id = 5;</code>
     * @return the buffId
     */
    public int getBuffId() {
      return buffId;
    }

    /**
     * <code>optional uint32 buff_id = 5;</code>
     * @param value the buffId to set
     * @return this
     */
    public JOOJNLEGJMM setBuffId(final int value) {
      bitField0_ |= 0x00000001;
      buffId = value;
      return this;
    }

    /**
     * <code>optional uint32 JAIMPOFNKFJ = 9;</code>
     * @return whether the jAIMPOFNKFJ field is set
     */
    public boolean hasJAIMPOFNKFJ() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 JAIMPOFNKFJ = 9;</code>
     * @return this
     */
    public JOOJNLEGJMM clearJAIMPOFNKFJ() {
      bitField0_ &= ~0x00000002;
      jAIMPOFNKFJ = 0;
      return this;
    }

    /**
     * <code>optional uint32 JAIMPOFNKFJ = 9;</code>
     * @return the jAIMPOFNKFJ
     */
    public int getJAIMPOFNKFJ() {
      return jAIMPOFNKFJ;
    }

    /**
     * <code>optional uint32 JAIMPOFNKFJ = 9;</code>
     * @param value the jAIMPOFNKFJ to set
     * @return this
     */
    public JOOJNLEGJMM setJAIMPOFNKFJ(final int value) {
      bitField0_ |= 0x00000002;
      jAIMPOFNKFJ = value;
      return this;
    }

    @Override
    public JOOJNLEGJMM copyFrom(final JOOJNLEGJMM other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        buffId = other.buffId;
        jAIMPOFNKFJ = other.jAIMPOFNKFJ;
      }
      return this;
    }

    @Override
    public JOOJNLEGJMM mergeFrom(final JOOJNLEGJMM other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasBuffId()) {
        setBuffId(other.buffId);
      }
      if (other.hasJAIMPOFNKFJ()) {
        setJAIMPOFNKFJ(other.jAIMPOFNKFJ);
      }
      return this;
    }

    @Override
    public JOOJNLEGJMM clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      buffId = 0;
      jAIMPOFNKFJ = 0;
      return this;
    }

    @Override
    public JOOJNLEGJMM clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof JOOJNLEGJMM)) {
        return false;
      }
      JOOJNLEGJMM other = (JOOJNLEGJMM) o;
      return bitField0_ == other.bitField0_
        && (!hasBuffId() || buffId == other.buffId)
        && (!hasJAIMPOFNKFJ() || jAIMPOFNKFJ == other.jAIMPOFNKFJ);
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 40);
        output.writeUInt32NoTag(buffId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(jAIMPOFNKFJ);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(buffId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(jAIMPOFNKFJ);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public JOOJNLEGJMM mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 40: {
            // buffId
            buffId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // jAIMPOFNKFJ
            jAIMPOFNKFJ = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.buffId, buffId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.jAIMPOFNKFJ, jAIMPOFNKFJ);
      }
      output.endObject();
    }

    @Override
    public JOOJNLEGJMM mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -1378119474:
          case 227990663: {
            if (input.isAtField(FieldNames.buffId)) {
              if (!input.trySkipNullValue()) {
                buffId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1447039763: {
            if (input.isAtField(FieldNames.jAIMPOFNKFJ)) {
              if (!input.trySkipNullValue()) {
                jAIMPOFNKFJ = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public JOOJNLEGJMM clone() {
      return new JOOJNLEGJMM().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static JOOJNLEGJMM parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new JOOJNLEGJMM(), data).checkInitialized();
    }

    public static JOOJNLEGJMM parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JOOJNLEGJMM(), input).checkInitialized();
    }

    public static JOOJNLEGJMM parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new JOOJNLEGJMM(), input).checkInitialized();
    }

    /**
     * @return factory for creating JOOJNLEGJMM messages
     */
    public static MessageFactory<JOOJNLEGJMM> getFactory() {
      return JOOJNLEGJMMFactory.INSTANCE;
    }

    private enum JOOJNLEGJMMFactory implements MessageFactory<JOOJNLEGJMM> {
      INSTANCE;

      @Override
      public JOOJNLEGJMM create() {
        return JOOJNLEGJMM.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName buffId = FieldName.forField("buffId", "buff_id");

      static final FieldName jAIMPOFNKFJ = FieldName.forField("JAIMPOFNKFJ");
    }
  }
}
